<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>BBR 数据包传输状态日志记录实现 </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="BBR 数据包传输状态日志记录实现 ">
      
      
      <link rel="icon" href="favicon.ico">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="">
      
      
      <meta name="docfx:docurl" content="https://github.com/QiangWu769/msquic_cellular/blob/main/BBR_PACKET_LOGGING_IMPLEMENTATION.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="bbr-数据包传输状态日志记录实现">BBR 数据包传输状态日志记录实现</h1>

<h2 id="概述">概述</h2>
<p>本实现在 MsQuic 的 BBR 拥塞控制算法中添加了详细的数据包传输日志记录功能，能够记录每次数据包传输时的 BBR 状态信息，包括带宽、RTT、拥塞窗口和丢包信息。</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="1-核心功能函数">1. 核心功能函数</h3>
<p>在 <code>src/core/bbr.c</code> 中添加了新的日志记录函数：</p>
<pre><code class="lang-c">_IRQL_requires_max_(DISPATCH_LEVEL)
void
BbrCongestionControlLogPacketSent(
    _In_ const QUIC_CONGESTION_CONTROL* Cc,
    _In_ uint32_t PacketSize
    )
</code></pre>
<p>该函数记录以下 BBR 状态信息：</p>
<ul>
<li><strong>PacketSize</strong>: 数据包大小（字节）</li>
<li><strong>EstimatedBandwidth</strong>: 估计带宽（字节/秒）</li>
<li><strong>SmoothedRtt</strong>: 平滑 RTT（微秒）</li>
<li><strong>MinRtt</strong>: 最小 RTT（微秒）</li>
<li><strong>CongestionWindow</strong>: 拥塞窗口大小（字节）</li>
<li><strong>BytesInFlight</strong>: 当前在途字节数</li>
<li><strong>PacketsInFlight</strong>: 当前在途数据包数</li>
<li><strong>BbrState</strong>: BBR 状态（STARTUP, DRAIN, PROBE_BW, PROBE_RTT）</li>
<li><strong>RecoveryState</strong>: 恢复状态</li>
<li><strong>TotalPacketsSent</strong>: 总发送数据包数</li>
<li><strong>TotalPacketsLost</strong>: 总丢失数据包数</li>
<li><strong>LossRate</strong>: 丢包率（百分比）</li>
</ul>
<h3 id="2-拥塞控制接口更新">2. 拥塞控制接口更新</h3>
<h4 id="21-接口定义-srccorecongestion_controlh">2.1 接口定义 (<code>src/core/congestion_control.h</code>)</h4>
<p>添加了新的函数指针到拥塞控制结构体：</p>
<pre><code class="lang-c">void (*QuicCongestionControlLogPacketSent)(
    _In_ const struct QUIC_CONGESTION_CONTROL* Cc,
    _In_ uint32_t PacketSize
    );
</code></pre>
<p>以及对应的内联函数：</p>
<pre><code class="lang-c">_IRQL_requires_max_(DISPATCH_LEVEL)
QUIC_INLINE
void
QuicCongestionControlLogPacketSent(
    _In_ const struct QUIC_CONGESTION_CONTROL* Cc,
    _In_ uint32_t PacketSize
    )
</code></pre>
<h4 id="22-bbr-实现">2.2 BBR 实现</h4>
<p>在 BBR 拥塞控制结构体中设置函数指针：</p>
<pre><code class="lang-c">.QuicCongestionControlLogPacketSent = BbrCongestionControlLogPacketSent,
</code></pre>
<h4 id="23-cubic-实现">2.3 Cubic 实现</h4>
<p>Cubic 算法不需要数据包级别的日志记录，因此设置为 NULL：</p>
<pre><code class="lang-c">.QuicCongestionControlLogPacketSent = NULL,
</code></pre>
<h3 id="3-调用时机">3. 调用时机</h3>
<p>在 <code>BbrCongestionControlOnDataSent</code> 函数中，每次数据包发送时调用日志记录函数：</p>
<pre><code class="lang-c">// Log BBR state for each packet transmission
BbrCongestionControlLogPacketSent(Cc, NumRetransmittableBytes);
</code></pre>
<h3 id="4-事件跟踪和日志">4. 事件跟踪和日志</h3>
<h4 id="41-etw-清单更新-srcmanifestmsquicetwman">4.1 ETW 清单更新 (<code>src/manifest/MsQuicEtw.man</code>)</h4>
<p>添加了新的 ETW 事件定义：</p>
<ul>
<li><strong>事件</strong>: <code>QuicConnBbrPacketSent</code> (值: 5196)</li>
<li><strong>模板</strong>: <code>tid_CONN_BBR_PACKET_SENT</code></li>
<li><strong>消息格式</strong>: <code>[conn][%1] BBR_TX: PktSize=%2 BW=%3 RTT=%4 MinRTT=%5 CWnd=%6 InFlight=%7 PktsInFlight=%8 State=%9 RState=%10 TotalSent=%11 TotalLost=%12 LossRate=%13%%</code></li>
</ul>
<h4 id="42-clog-头文件更新">4.2 CLOG 头文件更新</h4>
<p>更新了生成的日志头文件：</p>
<ul>
<li><code>src/generated/linux/bbr.c.clog.h</code></li>
<li><code>src/generated/linux/bbr.c.clog.h.lttng.h</code></li>
</ul>
<p>添加了 <code>ConnBbrPacketSent</code> 跟踪事件的宏定义和 LTTng 跟踪点。</p>
<h2 id="使用方法">使用方法</h2>
<h3 id="1-编译">1. 编译</h3>
<p>确保在编译 MsQuic 时启用了 BBR 拥塞控制和日志记录功能。</p>
<h3 id="2-运行时配置">2. 运行时配置</h3>
<p>使用 BBR 拥塞控制算法：</p>
<pre><code class="lang-c">QUIC_SETTINGS Settings = {0};
Settings.CongestionControlAlgorithm = QUIC_CONGESTION_CONTROL_ALGORITHM_BBR;
Settings.IsSet.CongestionControlAlgorithm = TRUE;
</code></pre>
<h3 id="3-日志收集">3. 日志收集</h3>
<h4 id="linux-lttng">Linux (LTTng)</h4>
<pre><code class="lang-bash"># 启用跟踪
lttng create msquic-session
lttng enable-event --userspace CLOG_BBR_C:ConnBbrPacketSent
lttng start

# 运行应用程序
./your_quic_application

# 停止跟踪
lttng stop
lttng view &gt; bbr_packet_logs.txt
</code></pre>
<h4 id="windows-etw">Windows (ETW)</h4>
<p>使用 WPA (Windows Performance Analyzer) 或其他 ETW 工具收集 <code>QuicConnBbrPacketSent</code> 事件。</p>
<h2 id="日志输出示例">日志输出示例</h2>
<pre><code>[conn][0x7f8c4c000000] BBR_TX: PktSize=1200 BW=12500000 RTT=25000 MinRTT=20000 CWnd=14400 InFlight=2400 PktsInFlight=2 State=0 RState=0 TotalSent=150 TotalLost=2 LossRate=1%
</code></pre>
<p>这表示：</p>
<ul>
<li>数据包大小：1200 字节</li>
<li>估计带宽：12.5 MB/s</li>
<li>平滑 RTT：25 毫秒</li>
<li>最小 RTT：20 毫秒</li>
<li>拥塞窗口：14400 字节</li>
<li>在途字节：2400 字节</li>
<li>在途数据包：2 个</li>
<li>BBR 状态：STARTUP (0)</li>
<li>恢复状态：NOT_RECOVERY (0)</li>
<li>总发送：150 个数据包</li>
<li>总丢失：2 个数据包</li>
<li>丢包率：1%</li>
</ul>
<h2 id="性能考虑">性能考虑</h2>
<ul>
<li>日志记录仅在 BBR 算法中启用</li>
<li>使用高效的跟踪机制（ETW/LTTng）</li>
<li>在生产环境中可通过配置禁用详细日志记录</li>
<li>对网络性能影响最小</li>
</ul>
<h2 id="扩展性">扩展性</h2>
<p>该实现为其他拥塞控制算法（如 Cubic）提供了扩展接口，可以根据需要添加类似的日志记录功能。</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/QiangWu769/msquic_cellular/blob/main/BBR_PACKET_LOGGING_IMPLEMENTATION.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
